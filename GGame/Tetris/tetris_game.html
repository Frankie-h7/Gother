<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Tetris</title>
    <style>
        :root {
            --bg-color: #121212;
            --grid-color: #1e1e1e;
            --highlight-color: #f5b700; /* Yellow ochre */
            --text-color: #ffffff;
            --grid-border-color: #333;
            --shadow-color: rgba(245, 183, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            overflow: hidden; /* Disabilita lo scroll globale */

                        /* Disabilita selezione testo */
                 -webkit-user-select: none; /* Safari */
                 -moz-user-select: none; /* Firefox */
                 -ms-user-select: none; /* IE10+/Edge */
                 user-select: none; /* Standard */

            /* Rimuove il flash blu su mobile */
                 -webkit-tap-highlight-color: transparent;
                 tap-highlight-color: transparent;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            max-width: 100%;
        }

        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                align-items: flex-start;
                gap: 20px;
            }
        }

        .game-board {
            position: relative;
            border: 2px solid var(--highlight-color);
            background-color: var(--grid-color);
            box-shadow: 0 0 15px var(--shadow-color);
         /* width: 300px;  */
         /* height: 600px; */
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);

             width: 90vw;  /* 90% della larghezza della viewport */
            height: 90vh; /* 90% dell'altezza della viewport */
            max-width: 300px; /* Limite massimo per non farlo diventare troppo grande */
             max-height: 600px; /* Limite massimo per non farlo diventare troppo grande */
        }

        .cell {
            border: 1px solid var(--grid-border-color);
            position: relative; /* Necessario per il posizionamento assoluto del tetromino */
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        @media (min-width: 768px) {
            .info-panel {
                margin-top: 0;
                align-items: flex-start;
            }
        }

        .next-piece-container {
            width: 120px;
            height: 120px;
            background-color: var(--grid-color);
            border: 2px solid var(--highlight-color);
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
        }

        .stats {
            background-color: var(--grid-color);
            border: 2px solid var(--highlight-color);
            padding: 15px;
            width: 160px;
            margin-bottom: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .stat-value {
            color: var(--highlight-color);
            font-weight: bold;
        }

        .controls {
            background-color: var(--grid-color);
            border: 2px solid var(--highlight-color);
            padding: 15px;
            width: 160px;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .key {
            background-color: var(--highlight-color);
            color: var(--bg-color);
            padding: 5px 10px;
            border-radius: 3px;
            margin-right: 10px;
            font-weight: bold;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .start-screen h1 {
            color: var(--highlight-color);
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--shadow-color);
        }

        .start-btn, .restart-btn {
            background-color: var(--highlight-color);
            color: var(--bg-color);
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .start-btn:hover, .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow-color);
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .game-over h2 {
            color: var(--highlight-color);
            font-size: 30px;
            margin-bottom: 10px;
        }

        .game-over p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .tetromino {
            position: absolute;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5);
            transition: transform 0.05s ease;
        }

        .shadow {
            position: absolute;
            background-color: var(--shadow-color);
            opacity: 0.3;
        }

        .pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .pause-screen h2 {
            color: var(--highlight-color);
            font-size: 30px;
            margin-bottom: 20px;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            width: 100%;
            max-width: 300px;
            margin-top: 20px;
        }

        .mobile-controls-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .mobile-btn {
            background-color: var(--grid-color);
            border: 2px solid var(--highlight-color);
            color: var(--highlight-color);
            font-size: 24px;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        @media (max-width: 767px) {
            .mobile-controls {
                display: block;
            }
        }

        /* Animation for line clear */
        @keyframes lineClear {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.5; }
            100% { transform: scale(1); opacity: 0; }
        }

        .flash {
            animation: lineClear 0.3s ease-out;
        }

        /* Progress bar for level */
        .level-progress {
            width: 160px;
            height: 10px;
            background-color: var(--grid-color);
            border: 1px solid var(--highlight-color);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .level-bar {
            height: 100%;
            background-color: var(--highlight-color);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-board" id="gameBoard">
            <!-- Grid cells will be generated by JavaScript -->
            
            <!-- Start Screen -->
            <div class="start-screen" id="startScreen">
                <h1>TETRIS</h1>
                <div class="controls">
                    <div class="control-row">
                        <div class="key">←</div>
                        <span>Move Left</span>
                    </div>
                    <div class="control-row">
                        <div class="key">→</div>
                        <span>Move Right</span>
                    </div>
                    <div class="control-row">
                        <div class="key">↑</div>
                        <span>Rotate</span>
                    </div>
                    <div class="control-row">
                        <div class="key">↓</div>
                        <span>Soft Drop</span>
                    </div>
                    <div class="control-row">
                        <div class="key">Space</div>
                        <span>Hard Drop</span>
                    </div>
                    <div class="control-row">
                        <div class="key">P</div>
                        <span>Pause</span>
                    </div>
                </div>
                <button class="start-btn" id="startBtn">START GAME</button>
            </div>
            
            <!-- Game Over Screen -->
            <div class="game-over" id="gameOverScreen">
                <h2>GAME OVER</h2>
                <p>Your score: <span id="finalScore">0</span></p>
                <button class="restart-btn" id="restartBtn">PLAY AGAIN</button>
            </div>

            <!-- Pause Screen -->
            <div class="pause-screen" id="pauseScreen">
                <h2>PAUSED</h2>
                <button class="restart-btn" id="resumeBtn">RESUME</button>
            </div>
        </div>

        <div class="info-panel">
            <h3>NEXT</h3>
            <div class="next-piece-container" id="nextPiece">
                <!-- Next piece preview will be here -->
            </div>
            
            <div class="stats">
                <div class="stat-row">
                    <span>SCORE</span>
                    <span class="stat-value" id="score">0</span>
                </div>
                <div class="stat-row">
                    <span>LINES</span>
                    <span class="stat-value" id="lines">0</span>
                </div>
                <div class="stat-row">
                    <span>LEVEL</span>
                    <span class="stat-value" id="level">1</span>
                </div>
            </div>

            <h3>LEVEL PROGRESS</h3>
            <div class="level-progress">
                <div class="level-bar" id="levelProgress"></div>
            </div>
            
            <div class="controls">
                <h3>CONTROLS</h3>
                <div class="control-row">
                    <div class="key">P</div>
                    <span>Pause</span>
                </div>
                <div class="control-row">
                    <div class="key">Space</div>
                    <span>Hard Drop</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="mobile-controls-row">
            <div class="mobile-btn" id="mobileRotate">↑</div>
            <div class="mobile-btn" id="mobileHardDrop">⬇️⬇️</div>
            <div class="mobile-btn" id="mobilePause">⏸️</div>
        </div>
        <div class="mobile-controls-row">
            <div class="mobile-btn" id="mobileLeft">←</div>
            <div class="mobile-btn" id="mobileDown">↓</div>
            <div class="mobile-btn" id="mobileRight">→</div>
        </div>
    </div>

    <script>
        // Constants and configurations
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const CELL_SIZE = 30; // Pixels per cell
        const INITIAL_DELAY = 800; // Initial delay in milliseconds between piece movements
        const MAX_LEVEL = 10;
        const LINES_PER_LEVEL = 10;

        // Tetromino shapes and colors
        const TETROMINOES = {
            I: {
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                color: '#00f0f0' // Cyan
            },
            J: {
                shape: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#0000f0' // Blue
            },
            L: {
                shape: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#f0a000' // Orange
            },
            O: {
                shape: [
                    [1, 1],
                    [1, 1]
                ],
                color: '#f0f000' // Yellow
            },
            S: {
                shape: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                color: '#00f000' // Green
            },
            T: {
                shape: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#a000f0' // Purple
            },
            Z: {
                shape: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                color: '#f00000' // Red
            }
        };

        // Game state
        let gameBoard;
        let currentPiece;
        let nextPiece;
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameInterval;
        let isPaused = false;
        let isGameOver = false;
        let shadowPiece;

        // DOM Elements
        const gameBoardElement = document.getElementById('gameBoard');
        const nextPieceElement = document.getElementById('nextPiece');
        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        const levelElement = document.getElementById('level');
        const levelProgressElement = document.getElementById('levelProgress');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const pauseScreen = document.getElementById('pauseScreen');
        const resumeBtn = document.getElementById('resumeBtn');

        // Mobile controls
        const mobileLeft = document.getElementById('mobileLeft');
        const mobileRight = document.getElementById('mobileRight');
        const mobileDown = document.getElementById('mobileDown');
        const mobileRotate = document.getElementById('mobileRotate');
        const mobileHardDrop = document.getElementById('mobileHardDrop');
        const mobilePause = document.getElementById('mobilePause');

        // Audio elements
        const moveSound = new Audio('sound-effects/moveSound.wav');
        const rotateSound = new Audio('sound-effects/rotateSound.wav');
        const dropSound = new Audio('sound-effects/dropSound.flac');
        const lineClearSound = new Audio('sound-effects/lineClearSound.wav');
        const gameOverSound = new Audio('sound-effects/gameOverSound.wav');

        // Background music
        const bgMusic = new Audio('sound-effects/bgMusic.wav');
        bgMusic.loop = true;
        bgMusic.volume = 0.3;

        // Initialize the game
        function initGame() {
            // Create game board grid
            createGameBoard();
            
            // Create next piece preview grid
            createNextPiecePreview();
            
            // Initialize the game state
            resetGame();
            
            // Set up event listeners
            setupEventListeners();
        }

        // Create the game board grid
        function createGameBoard() {
            // Clear any existing elements
            gameBoardElement.innerHTML = '';
            
            // Append the game screens back (they were cleared above)
            gameBoardElement.appendChild(startScreen);
            gameBoardElement.appendChild(gameOverScreen);
            gameBoardElement.appendChild(pauseScreen);
            
            // Create the cells for the game board
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    gameBoardElement.appendChild(cell);
                }
            }
        }

        // Create the next piece preview grid
        function createNextPiecePreview() {
            nextPieceElement.innerHTML = '';
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    nextPieceElement.appendChild(cell);
                }
            }
        }

        // Reset the game state
        function resetGame() {
            // Initialize an empty game board
            gameBoard = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
            
            // Reset game state variables
            score = 0;
            lines = 0;
            level = 1;
            isPaused = false;
            isGameOver = false;
            
            // Update UI elements
            updateScore();
            updateLevel();
            updateLinesCleared();
            updateLevelProgress();
            
            // Generate the first pieces
            nextPiece = getRandomTetromino();
            spawnNewPiece();
            
            // Clear any existing game interval
            if (gameInterval) {
                clearInterval(gameInterval);
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', handleKeyPress);
            
            // Start button
            startBtn.addEventListener('click', startGame);
            
            // Restart button
            restartBtn.addEventListener('click', restartGame);
            
            // Resume button
            resumeBtn.addEventListener('click', togglePause);
            
            // Mobile controls
            mobileLeft.addEventListener('touchstart', () => moveHorizontal(-1));
            mobileRight.addEventListener('touchstart', () => moveHorizontal(1));
            mobileDown.addEventListener('touchstart', () => softDrop(true));
            mobileDown.addEventListener('touchend', () => softDrop(false));
            mobileRotate.addEventListener('touchstart', rotatePiece);
            mobileHardDrop.addEventListener('touchstart', hardDrop);
            mobilePause.addEventListener('touchstart', togglePause);
        }

        // Handle keyboard input
        function handleKeyPress(event) {
            if (isGameOver || startScreen.style.display !== 'none') return;
            
            switch (event.key) {
                case 'ArrowLeft':
                    moveHorizontal(-1);
                    break;
                case 'ArrowRight':
                    moveHorizontal(1);
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case 'ArrowDown':
                    softDrop(true);
                    break;
                case ' ':
                    hardDrop();
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
            }
        }

        document.addEventListener('keyup', (event) => {
            if (event.key === 'ArrowDown') {
                softDrop(false);
            }
        });

        // Start the game
        function startGame() {
            startScreen.style.display = 'none';
            
            // Start the game loop
            gameInterval = setInterval(gameLoop, INITIAL_DELAY);
            
            // Start background music
            bgMusic.play();
        }

        // Restart the game
        function restartGame() {
            gameOverScreen.style.display = 'none';
            resetGame();
            startGame();
        }

        // Toggle pause state
        function togglePause() {
            if (isGameOver) return;
            
            isPaused = !isPaused;
            
            if (isPaused) {
                clearInterval(gameInterval);
                pauseScreen.style.display = 'flex';
                bgMusic.pause();
            } else {
                gameInterval = setInterval(gameLoop, getGameSpeed());
                pauseScreen.style.display = 'none';
                bgMusic.play();
            }
        }

        // Get a random tetromino
        function getRandomTetromino() {
            const tetrominoTypes = Object.keys(TETROMINOES);
            const randomType = tetrominoTypes[Math.floor(Math.random() * tetrominoTypes.length)];
            
            return {
                type: randomType,
                shape: TETROMINOES[randomType].shape,
                color: TETROMINOES[randomType].color,
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOES[randomType].shape[0].length / 2),
                y: 0
            };
        }

        // Spawn a new piece
        function spawnNewPiece() {
            currentPiece = nextPiece;
            nextPiece = getRandomTetromino();
            
            // Update the next piece preview
            updateNextPiecePreview();
            
            // Update the shadow piece
            updateShadowPiece();
            
            // Check if the game is over (collision on spawn)
            if (checkCollision(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                gameOver();
            }
            
            // Draw the current piece
            drawPiece();
        }

        // Update the next piece preview
        function updateNextPiecePreview() {
            // Clear the preview area
            const previewCells = nextPieceElement.querySelectorAll('.cell');
            previewCells.forEach(cell => {
                cell.innerHTML = '';
            });
            
            // Draw the next piece in the preview area
            const shape = nextPiece.shape;
            const color = nextPiece.color;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const cellX = x;
                        const cellY = y;
                        
                        // Find the corresponding cell in the preview grid
                        const cell = nextPieceElement.querySelector(`[data-x="${cellX}"][data-y="${cellY}"]`);
                        
                        if (cell) {
                            const tetromino = document.createElement('div');
                            tetromino.className = 'tetromino';
                            tetromino.style.backgroundColor = color;
                            cell.appendChild(tetromino);
                        }
                    }
                }
            }
        }

        // Update shadow piece (projection of where the piece will land)
        function updateShadowPiece() {
            // Remove existing shadow pieces
            const shadows = document.querySelectorAll('.shadow');
            shadows.forEach(shadow => shadow.remove());
            
            if (!currentPiece) return;
            
            // Calculate drop position
            let dropY = currentPiece.y;
            
            while (!checkCollision(currentPiece.x, dropY + 1, currentPiece.shape)) {
                dropY++;
            }
            
            // Draw shadow at the drop position
            shadowPiece = {
                ...currentPiece,
                y: dropY
            };
            
            drawShadow();
        }

        // Draw the shadow piece
        function drawShadow() {
            if (!shadowPiece) return;
            
            const shape = shadowPiece.shape;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = shadowPiece.x + x;
                        const boardY = shadowPiece.y + y;
                        
                        if (boardY >= 0) {
                            const cell = gameBoardElement.querySelector(`[data-x="${boardX}"][data-y="${boardY}"]`);
                            
                            if (cell && !cell.querySelector('.tetromino')) {
                                const shadow = document.createElement('div');
                                shadow.className = 'shadow';
                                cell.appendChild(shadow);
                            }
                        }
                    }
                }
            }
        }

        // Draw the current piece
        function drawPiece() {
            const shape = currentPiece.shape;
            const color = currentPiece.color;
            
            // First, remove any previous tetromino elements that are not locked in place
            const existingPieces = document.querySelectorAll('.tetromino:not([data-locked="true"])');
            existingPieces.forEach(piece => piece.remove());
            
            // Then draw the current piece
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = currentPiece.x + x;
                        const boardY = currentPiece.y + y;
                        
                        if (boardY >= 0) {
                            const cell = gameBoardElement.querySelector(`[data-x="${boardX}"][data-y="${boardY}"]`);
                            
                            if (cell) {
                                const tetromino = document.createElement('div');
                                tetromino.className = 'tetromino';
                                tetromino.style.backgroundColor = color;
                                cell.appendChild(tetromino);
                            }
                        }
                    }
                }
            }
        }

        // Check for collision
        function checkCollision(x, y, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardX = x + col;
                        const boardY = y + row;
                        
                        // Check boundaries
                        if (
                            boardX < 0 || 
                            boardX >= BOARD_WIDTH || 
                            boardY >= BOARD_HEIGHT || 
                            (boardY >= 0 && gameBoard[boardY][boardX])
                        ) {
                            return true; // Collision detected
                        }
                    }
                }
            }
            
            return false; // No collision
        }

        // Lock the current piece in place
        function lockPiece() {
            const shape = currentPiece.shape;
            const color = currentPiece.color;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = currentPiece.x + x;
                        const boardY = currentPiece.y + y;
                        
                        if (boardY >= 0) {
                            // Update the game board array
                            gameBoard[boardY][boardX] = color;
                            
                            // Mark the tetromino element as locked
                            const cell = gameBoardElement.querySelector(`[data-x="${boardX}"][data-y="${boardY}"]`);
                            if (cell && cell.querySelector('.tetromino')) {
                                const tetromino = cell.querySelector('.tetromino');
                                tetromino.dataset.locked = 'true';
                            }
                        }
                    }
                }
            }
            
            // Play drop sound
            dropSound.currentTime = 0;
            dropSound.play();
            
            // Check for completed lines
            checkLines();
            
            // Spawn a new piece
            spawnNewPiece();
        }

        // Move the current piece horizontally
        function moveHorizontal(direction) {
            if (isPaused || isGameOver) return;
            
            const newX = currentPiece.x + direction;
            
            if (!checkCollision(newX, currentPiece.y, currentPiece.shape)) {
                currentPiece.x = newX;
                
                // Play move sound
                moveSound.currentTime = 0;
                moveSound.play();
                
                // Update shadow piece
                updateShadowPiece();
                
                // Redraw the piece
                drawPiece();
            }
        }

        // Rotate the current piece
        function rotatePiece() {
            if (isPaused || isGameOver) return;
            
            const originalShape = currentPiece.shape;
            const rotatedShape = rotateMatrix(originalShape);
            
            // Check if the rotation would cause a collision
            if (!checkCollision(currentPiece.x, currentPiece.y, rotatedShape)) {
                currentPiece.shape = rotatedShape;
                
                // Play rotate sound
                rotateSound.currentTime = 0;
                rotateSound.play();
                
                // Update shadow piece
                updateShadowPiece();
                
                // Redraw the piece
                drawPiece();
            } else {
                // Try wall kick (shift to prevent collision)
                for (let offset = 1; offset <= 2; offset++) {
                    // Try right wall kick
                    if (!checkCollision(currentPiece.x + offset, currentPiece.y, rotatedShape)) {
                        currentPiece.x += offset;
                        currentPiece.shape = rotatedShape;
                        
                        // Play rotate sound
                        rotateSound.currentTime = 0;
                        rotateSound.play();
                        
                        // Update shadow piece
                        updateShadowPiece();
                        
                        // Redraw the piece
                        drawPiece();
                        return;
                    }
                    
                    // Try left wall kick
                    if (!checkCollision(currentPiece.x - offset, currentPiece.y, rotatedShape)) {
                        currentPiece.x -= offset;
                        currentPiece.shape = rotatedShape;
                        
                        // Play rotate sound
                        rotateSound.currentTime = 0;
                        rotateSound.play();
                        
                        // Update shadow piece
                        updateShadowPiece();
                        
                        // Redraw the piece
                        drawPiece();
                        return;
                    }
                    
                    // Try up kick (for bottom collisions)
                    if (!checkCollision(currentPiece.x, currentPiece.y - offset, rotatedShape)) {
                        currentPiece.y -= offset;
                        currentPiece.shape = rotatedShape;
                        
                        // Play rotate sound
                        rotateSound.currentTime = 0;
                        rotateSound.play();
                        
                        // Update shadow piece
                        updateShadowPiece();
                        
                        // Redraw the piece
                        drawPiece();
                        return;
                    }
                }
            }
        }

        // Rotate a matrix 90 degrees clockwise
        function rotateMatrix(matrix) {
            const N = matrix.length;
            const rotated = Array(N).fill().map(() => Array(N).fill(0));
            
            // Transpose the matrix
            for (let y = 0; y < N; y++) {
                for (let x = 0; x < N; x++) {
                    rotated[x][N - 1 - y] = matrix[y][x];
                }
            }
            
            return rotated;
        }

        // Soft drop - move the piece down faster
        function softDrop(isActive) {
            if (isPaused || isGameOver) return;
            
            if (isActive) {
                // Clear the normal interval and set a faster one
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, getGameSpeed() / 4);
            } else {
                // Reset to normal speed
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, getGameSpeed());
            }
        }

        // Hard drop - instantly drop the piece to the bottom
        function hardDrop() {
            if (isPaused || isGameOver) return;
            
            // Find the drop position
            let dropY = currentPiece.y;
            
            while (!checkCollision(currentPiece.x, dropY + 1, currentPiece.shape)) {
                dropY++;
            }
            
            // Move the piece to the drop position
            currentPiece.y = dropY;
            
            // Update the board
            drawPiece();
            
            // Lock the piece immediately
            lockPiece();
        }

        // Check for completed lines
        function checkLines() {
            let linesCleared = 0;
            
            // Check each row from bottom to top
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                // Check if the row is completely filled
                if (gameBoard[y].every(cell => cell !== 0)) {
                    // Animate the line clear
                    animateLineClear(y);
                    
                    // Remove the line
                    gameBoard.splice(y, 1);
                    
                    // Add an empty line at the top
                    gameBoard.unshift(Array(BOARD_WIDTH).fill(0));
                    
                    // Increment lines cleared
                    linesCleared++;
                    
                    // Since we removed a line, we need to check the same y-index again
                    y++;
                }
            }
            
            // Update the game state if lines were cleared
            if (linesCleared > 0) {
                // Play line clear sound
                lineClearSound.currentTime = 0;
                lineClearSound.play();
                
                // Update lines and score
                lines += linesCleared;
                updateLinesCleared();
                
                // Calculate score based on number of lines cleared and level
                const scorePoints = calculateScore(linesCleared);
                score += scorePoints;
                updateScore();
                
                // Check for level up
                checkLevelUp();
                
                // Redraw the board to reflect changes
                redrawBoard();
            }
        }

        // Animate line clear
        function animateLineClear(row) {
            const cells = gameBoardElement.querySelectorAll(`[data-y="${row}"]`);
            
            cells.forEach(cell => {
                const tetromino = cell.querySelector('.tetromino');
                if (tetromino) {
                    tetromino.classList.add('flash');
                    setTimeout(() => {
                        tetromino.remove();
                    }, 300);
                }
            });
        }

        // Calculate score based on lines cleared and level
        function calculateScore(linesCleared) {
            // Classic Tetris scoring system
            const linePoints = [40, 100, 300, 1200]; // Points for 1, 2, 3, 4 lines
            return linePoints[linesCleared - 1] * level;
        }

        // Check if player should level up
        function checkLevelUp() {
            const newLevel = Math.floor(lines / LINES_PER_LEVEL) + 1;
            
            if (newLevel > level && newLevel <= MAX_LEVEL) {
                level = newLevel;
                updateLevel();
                
                // Update game speed
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, getGameSpeed());
            }
            
            // Update level progress bar
            updateLevelProgress();
        }

        // Update level progress bar
        function updateLevelProgress() {
            const linesForCurrentLevel = (level - 1) * LINES_PER_LEVEL;
            const linesProgress = lines - linesForCurrentLevel;
            const progressPercent = (linesProgress / LINES_PER_LEVEL) * 100;
            
            levelProgressElement.style.width = `${progressPercent}%`;
        }

        // Get game speed based on current level
        function getGameSpeed() {
            // Decrease delay as level increases (making the game faster)
            return INITIAL_DELAY * Math.pow(0.8, level - 1);
        }

        // Update score display
        function updateScore() {
            scoreElement.textContent = score;
        }

        // Update level display
        function updateLevel() {
            levelElement.textContent = level;
        }

        // Update lines cleared display
        function updateLinesCleared() {
            linesElement.textContent = lines;
        }

        // Redraw the entire board
        function redrawBoard() {
            // Clear all non-locked tetromino elements
            const existingPieces = document.querySelectorAll('.tetromino:not([data-locked="true"])');
            existingPieces.forEach(piece => piece.remove());
            
            // Clear locked pieces
            const lockedPieces = document.querySelectorAll('.tetromino[data-locked="true"]');
            lockedPieces.forEach(piece => piece.remove());
            
            // Redraw the locked pieces based on gameBoard array
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (gameBoard[y][x]) {
                        const color = gameBoard[y][x];
                        const cell = gameBoardElement.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                        
                        if (cell) {
                            const tetromino = document.createElement('div');
                            tetromino.className = 'tetromino';
                            tetromino.style.backgroundColor = color;
                            tetromino.dataset.locked = 'true';
                            cell.appendChild(tetromino);
                        }
                    }
                }
            }
            
            // Redraw the current piece
            drawPiece();
            
            // Update shadow piece
            updateShadowPiece();
        }

        // Game over
        function gameOver() {
            isGameOver = true;
            clearInterval(gameInterval);
            
            // Play game over sound
            gameOverSound.currentTime = 0;
            gameOverSound.play();
            bgMusic.pause();
            
            // Show game over screen
            gameOverScreen.style.display = 'flex';
            finalScoreElement.textContent = score;
        }

        // Main game loop
        function gameLoop() {
            if (isPaused || isGameOver) return;
            
            // Move the current piece down
            const newY = currentPiece.y + 1;
            
            if (!checkCollision(currentPiece.x, newY, currentPiece.shape)) {
                currentPiece.y = newY;
                drawPiece();
            } else {
                // If we can't move down, lock the piece in place
                lockPiece();
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>